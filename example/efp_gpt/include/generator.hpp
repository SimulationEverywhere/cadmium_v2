#ifndef CADMIUM_EXAMPLE_GPT_GENERATOR_HPP_
#define CADMIUM_EXAMPLE_GPT_GENERATOR_HPP_

#include <cadmium/modeling/devs/atomic.hpp>
#include <iostream>
#include "job.hpp"

namespace cadmium::example::gpt {
	//! Class for representing the Generator DEVS model state.
	struct GeneratorState {
		double clock;  //!< Current simulation time.
		double sigma;  //!< Time to wait before triggering the next internal transition function.
		int jobCount;  //!< Number of jobs generated by the Generator model so far.

		//! Constructor function. It sets all the attributes to 0.
		GeneratorState(): clock(), sigma(), jobCount() {}
	};

	/**
	 * Insertion operator for GeneratorState objects. It only displays the value of jobCount.
	 * @param out output stream.
	 * @param s state to be represented in the output stream.
	 * @return output stream with jobCount already inserted.
	 */
	std::ostream& operator<<(std::ostream& out, const GeneratorState& s) {
		out << s.jobCount;
		return out;
	}

	//! Atomic DEVS model of a Job generator.
	class Generator : public Atomic<GeneratorState> {
	 private:
		double jobPeriod;                            //!< Time to wait between Job generations.
	 public:
		Port<bool> inStop;          //!< Input Port for receiving stop generating Job objects.
		BigPort<Job> outGenerated;  //!< Output Port for sending new Job objects to be processed.

		/**
		 * Constructor function for Generator DEVS model.
		 * @param id model ID.
		 * @param jobPeriod Job generation period.
		 */
		Generator(const std::string& id, double jobPeriod): Atomic<GeneratorState>(id, GeneratorState()), jobPeriod(jobPeriod) {
			inStop = addInPort<bool>("inStop");
			outGenerated = addOutBigPort<Job>("outGenerated");
		}

		/**
		 * Updates GeneratorState::clock and GeneratorState::sigma and increments GeneratorState::jobCount by one.
		 * @param s reference to the current generator model state.
		 */
		void internalTransition(GeneratorState& s) const override {
			s.clock += s.sigma;
			s.sigma = jobPeriod;
			s.jobCount += 1;
		}

		/**
		 * Updates GeneratorState::clock and GeneratorState::sigma.
		 * If it receives a true message via the Generator::inStop port, it passivates and stops generating Job objects.
		 * @param s reference to the current generator model state.
		 * @param e time elapsed since the last state transition function was triggered.
		 * @param x reference to the atomic model input port set.
		 */
		void externalTransition(GeneratorState& s, double e) const override {
			s.clock += e;
			s.sigma = std::max(s.sigma - e, 0.);
			if (!inStop->empty() && inStop->getBag().back()) {
				s.sigma = std::numeric_limits<double>::infinity();
			}
		}

		/**
		 * Sends a new Job that needs to be processed via the Generator::outGenerated port.
		 * @param s reference to the current generator model state.
		 * @param y reference to the atomic model output port set.
		 */
		void output(const GeneratorState& s) const override {
			outGenerated->addMessage(s.jobCount, s.clock + s.sigma);
			// outGenerated->addMessage(Job(s.jobCount, s.clock + s.sigma)); // TODO we could also do this
		}

		/**
		 * It returns the value of GeneratorState::sigma.
		 * @param s reference to the current generator model state.
		 * @return the sigma value.
		 */
		[[nodiscard]] double timeAdvance(const GeneratorState& s) const override {
			return s.sigma;
		}
	};
}  //namespace cadmium::example::gpt

#endif //CADMIUM_EXAMPLE_GPT_GENERATOR_HPP_
